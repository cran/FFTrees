---
title: "Manually specifying FFTs"
author: "Nathaniel Phillips and HansjÃ¶rg Neth"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: fft.bib
csl: apa.csl 
vignette: >
  %\VignetteIndexEntry{Manually specifying FFTs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      fig.width = 6.5, 
                      fig.height = 6.5, 
                      dpi = 100, 
                      out.width = "600px", 
                      fig.align='center', 
                      message = FALSE)
```


```{r load-pkg-0, echo = FALSE, message = FALSE, results = 'hide'}
library(FFTrees)
```


## Manually specifying FFTs 

We typically create fast-and-frugal trees (FFTs) from data by using the `FFTrees()` function (see the [Main guide](guide.html), the vignette on [Creating FFTs with FFTrees()](FFTrees_function.html) and for details). 
However, we sometimes want to design and test some specific FFT (e.g., to check a hypothesis or using some variables based on theoretical considerations). 

There are two ways to define fast-and-frugal trees manually when using the `FFTrees()` function: 

1. as a sentence using the `my.tree` argument (the easier way), or  

2. as a data frame using the `tree.definitions` argument (the harder way).  

Both of these methods will bypass the tree construction algorithms built into the **FFTrees** package.


### Using `my.tree`

The first method is to use the `my.tree` argument, where `my.tree` is a sentence describing a (single) FFT. 
When this argument is specified in `FFTrees()`, the function (specifically, an auxiliary `fftrees_wordstofftrees()` function) will try to convert the verbal description into the definition of a FFT (of an `FFTrees` object). 

For example, let's look at the `heartdisease` data to find out how some predictor variables (e.g., `sex`, `age`, etc.) predict the criterion variable (`diagnosis`):

```{r heart-data, echo = FALSE}
knitr::kable(head(heartdisease[c("sex", "age", "thal", "cp", "ca", 
                                 "diagnosis")]))
```

Table: **Table 1**: Five cues and the binary criterion variable `diagnosis` for the first cases of the `heartdisease` data. 

<!-- Verbal description of an FFT: -->

Here's how we could verbally describe an FFT by using the first three cues in conditional sentences: 

```{r fft-description}
in_words <- "If sex = 1, predict True.
             If age < 45, predict False. 
             If thal = {fd, normal}, predict True. 
             Otherwise, predict False."
```

As we will see shortly, the `FFTrees()` function accepts such descriptions (assigned here to a character string `in_words`) as its `my.tree` argument, create a corresponding FFT, and evaluate it on a corresponding dataset. 


#### How to define FFTs 

Here are some **instructions** for manually specifying trees: 

- Each node must start with the word "If" and should correspond to the form: `If <CUE> <DIRECTION> <THRESHOLD>, predict <EXIT>`.

- Numeric thresholds should be specified directly (without brackets), like `age > 21`. 

- For categorical variables, factor thresholds must be specified within curly braces, like `sex = {male}`. 
For factors with sets of values, categories within a threshold should be separated by commas like `eyecolor = {blue,brown}`. 

- To specify cue directions, standard logical comparisons `=`, `!=`, `<`, `>=` (etc.) are valid. 
For numeric cues, only use `>`, `>=`, `<`, or\ `<=`. For factors, only use `=` or\ `!=`.

- Positive exits are indicated by `True`, while negative exits are specified by `False`. 

- The final node of an FFT is always bi-directional (i.e., has both a positive and a negative exit). 
The description of the final node always mentions its positive (`True`) exit first. 
The text `Otherwise, predict EXIT` that we have included in the example above is actually not necessary (and ignored). 


#### Example 

Now, let's use our verbal description of an FFT (assigned to `in_words` above) as the `my.tree` argument of the `FFTrees()` function. 
This creates a corresponding FFT and applies it to the `heartdisease` data:

```{r create-my-tree, message = FALSE}
# Create FFTrees from a verbal FFT description (as my.tree): 
my_fft <- FFTrees(diagnosis ~.,
                  data = heartdisease,
                  main = "My 1st FFT", 
                  my.tree = in_words)
```

Let's see how well our manually constructed FFT (`my_fft`) did:

```{r plot-my-tree, fig.cap="**Figure 1**: An FFT manually constructed using the `my.tree` argument of `FFTrees()`.", fig.show='hold'}
# Inspect FFTrees object:
plot(my_fft)
```

<!-- Note absence of ROC curve: -->

When manually constructing a tree, the resulting `FFTrees` object only contains a single FFT. 
Hence, the ROC plot (in the right bottom panel of **Figure\ 1**) cannot show a range of FFTs, but locates the constructed FFT in ROC space. 

<!-- Performance: -->

As it turns out, the performance of our first FFT created from a verbal description is a mixed affair: 
The tree has a rather high sensitivity (of\ 91%), but its low specificity (of only\ 10%) allows for many false alarms. 
Consequently, its accuracy measures are only around baseline level. 


#### Creating an alternative FFT

Let's see if we can come up with a better FFT. 
The following example uses the cues\ `thal`, `cp`, and\ `ca` in the `my.tree` argument: 

```{r verbal-spec-fft, fig.cap="**Figure 2**: Another FFT manually constructed using the `my.tree` argument of `FFTrees()`.", fig.show='hold'}
# Create 2nd FFTrees from an alternative FFT description (as my.tree): 
my_fft_2 <- FFTrees(diagnosis ~.,
                    data = heartdisease, 
                    main = "My 2nd FFT", 
                    my.tree = "If thal = {rd,fd}, predict True.
                               If cp != {a}, predict False. 
                               If ca > 1, predict True. 
                               Otherwise, predict False.")

# Inspect FFTrees object:
plot(my_fft_2)
```

This alternative FFT is nicely balancing sensitivity and specificity and performs much better overall. 
Nevertheless, it is still far from perfect ---\ so check out whether you can create even better ones! 

<!-- TESTing: --> 

<!-- 1. In `fftrees_wordstofftrees()`, "Otherwise" part is being ignored. --> 
<!-- 2. In `fftrees_ffttowords()`, the final sentence always predicts positive (True) instances first. --> 

```{r checking-my-tree, echo = FALSE, eval = FALSE}
# 1. FFT with 2 cues (final cue is categorical): ------ 
fft_1 <- FFTrees(diagnosis ~.,
                    data = heartdisease, main = "My test 1", 
                    my.tree = "If age < 45, predict False. 
                               If thal = {fd, normal}, predict True.
                               Otherwise, predict the opposite.")

# inspect:
fft_1$trees$definitions
# Note 1: 
# Corrected an error in the direction definition of the final node: 
# When 1st part of last sentence predicts TRUE, 
# the final direction must not be negated.

plot(fft_1)
fft_1
inwords(fft_1)


# 2. Reverse cue order (i.e, final cue is numeric), but set to True (by reversing cue direction): ------ 
fft_2 <- FFTrees(diagnosis ~.,
                    data = heartdisease, main = "My test 2", 
                    my.tree = "If thal = {fd, normal}, predict true!
                               If age >= 45, predict TRUE (again)! 
                               Otherwise, go crazy (but mention 'FALSE' somewhere)...")
# inspect:
fft_2$trees$definitions
# Notes:
# - The final sentence always predicts positive (True) instances first. 
#   When the description predicted False instances first, the cue direction WAS reversed. 
# - Note improved robustness against lower/uppercase spellings/typos in cue labels. 

plot(fft_2)
inwords(fft_2)
fft_2

# Comparing my_fft_1 and my_fft_2 shows that cue order matters:
# In my_fft_1, the initial age cue causes few misses, but the 2nd thal cue makes more error than correct cases.
# In my_fft_2, the initial thal cue causes many false alarms, and the 2nd age cue also is too liberal (on FA).


# 3. Example used by Nathaniel (and skipping "otherwise" part of final node): ------ 
fft_3 <- FFTrees(formula = diagnosis ~., 
                 data = heart.train,
                 data.test = heart.test, main = "My test 3", 
                 decision.labels = c("Healthy", "Disease"),
                 my.tree = "If sex = 1, predict Disease.
                            If age < 45, predict Healthy.
                            If thal = {fd, normal}, predict Disease. 
                            (etc.)")

fft_3$trees$definitions
plot(fft_3)
inwords(fft_3)
fft_3


# 4. The shortest possible my.tree: ------ 
fft_4 <- FFTrees(formula = survived ~., 
                 data = titanic, main = "My test 4", 
                 my.tree = "If sex = {female} true.") # ignore otherwise/else part

plot(fft_4)
# Note:
# - Warning that 'False' does not occur in specification, but FFT is valid and constructed.
# - fft_4 shows good specificity (i.e., few false alarms, relative to high number of correct rejections), 
#   but poor sensitivity (many misses).
#   Overall accuracy is 10% above baseline (predicting False for all cases).
```


<!-- ToDo: 2nd way to specify an FFT:  -->

<!--       2. as a data frame using the `tree.definitions` argument  -->

```{r design-fft-df, echo = FALSE, eval = FALSE}
# Modify an existing FFT:
heart.fft <- FFTrees(formula = diagnosis ~ .,           # Criterion and (all) predictors
                     data = heart.train,                # Training data
                     data.test = heart.test,            # Testing data
                     main = "Heart Disease",            # General label
                     decision.labels = c("Low-Risk", "High-Risk"))  # Labels for decisions

# Current FFTs:
heart.fft$trees$definition

# Start from an existing FFT: 
my.fft <- heart.fft$trees$definitions[1, ]  

# Make some changes:
my.fft["tree"]  <- 8 
my.fft["exits"] <- c("1;1;0.5")

# Add to existing FFTs (as a new / 8th row):
heart.fft$trees$definition[8, ] <- my.fft
heart.fft$trees$n <- 8

# Use new FFT to predict same / new data:
predict(heart.fft, newdata = heartdisease, tree = 8)  # yields an ERROR...
```

For details on understanding and changing tree definitions, see the section on **Tree definitions** in the [Creating FFTs with FFTrees()](FFTrees_function.html) vignette. 


## Vignettes

<!-- Table of all vignettes: -->

Here is a complete list of the vignettes available in the **FFTrees** package: 

|   | Vignette | Description |
|--:|:------------------------------|:-------------------------------------------------|
|   | [Main guide](guide.html) | An overview of the **FFTrees** package |
| 1 | [Heart Disease Tutorial](FFTrees_heart.html)   | An example of using `FFTrees()` to model heart disease diagnosis |
| 2 | [Accuracy statistics](FFTrees_accuracy_statistics.html) | Definitions of accuracy statistics used throughout the package |
| 3 | [Creating FFTs with FFTrees()](FFTrees_function.html) | Details on the main function `FFTrees()` |
| 4 | [Specifying FFTs directly](FFTrees_mytree.html)   | How to directly create FFTs with `my.tree` without using the built-in algorithms |
| 5 | [Visualizing FFTs with plot()](FFTrees_plot.html) | Plotting `FFTrees` objects, from full trees to icon arrays |
| 6 | [Examples of FFTs](FFTrees_examples.html) | Examples of FFTs from different datasets contained in the package |


<!-- eof. -->
